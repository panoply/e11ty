<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
</head>
<body>
  <h1>Tutorial</h1>
<p>SPX operates under the assumption that developers possess an intermediate level of frontend knowledge. Before delving into this tutorial, it’s essential to familiarize yourself with a few <a href="/introduction/key-concepts">key concepts</a> and gain a basic understanding of how SPX functions. We’ll be utilizing a sample project available on <a href="#">GitHub</a>, covering the major aspects of SPX along the way.</p>
<p>This tutorial will demonstrate SPX usage in TypeScript using the <a href="https://pnpm.io">pnpm</a> package manager and <a href="https://tsup.egoist.dev">tsup</a> bundler. However, if you’re not using TypeScript or prefer a different development stack, feel free to make necessary adjustments to suit your preferences.</p>
<hr>
<h1>Install SPX</h1>
<p>To begin, let’s install SPX into your project. SPX is an ESM (ECMAScript Module) module, so it’s crucial to ensure that your <code>package.json</code> file is marked with the type <code>module</code>.</p>
<blockquote>
<p>For additional information on installation, you can refer to the <a href="/introduction/installation">Installation</a> page.</p>
</blockquote>
<pre><code class="language-bash">$ pnpm add spx --save     # Install as dependency in your project
</code></pre>
<h1>Project Structure</h1>
<p>In this tutorial, we’ll create components and explore various capabilities of SPX. While there’s no strict structure imposed, for the sake of brevity and simplicity, we’ll assume that your project follows the following directory structure:</p>
<pre><code class="language-treeview">/
└── src/
    ├── app/                      # This directory will contain your .ts files
    │   ├── components/     # This is where we will place our components
    │   └── bundle.ts      # This is our entry point file
    ├── views/                  # This directory contains our static pages
    ├── package.json
    ├── tsconfig.json
    └── tsup.config.ts
</code></pre>
<hr>
<h1>Connect SPX</h1>
<p>To establish SPX as the communication point of your application, we’ll use it as our default export and initialize it using the <code>{js} spx()</code> method. This method requires no options initially and will use the defaults. Once SPX is connected, it will take over the rendering cycle of your web application. Add the following code to your <code>bundle.ts</code> file:</p>
<!-- prettier-ignore -->
<pre><code class="language-ts">import spx from 'spx';

spx(/* options */)(function () {

  console.log('SPX Connected!');

});
</code></pre>
<blockquote>
<p>By default, SPX will morph the entire <code>&lt;body&gt;</code> content between navigations. If you wish to adjust this behavior, you can do so using the <code>fragments</code> option. However, for now, let’s stick to the basic configuration provided above. You can find more information about fragments in the <a href="/introduction/key-concepts">Key Concepts</a> page.</p>
</blockquote>
<h1>Script Evaluation</h1>
<p>In SPX, adherence to two crucial rules is paramount. Firstly, it’s imperative to include JavaScript files within the <code>{html} &lt;head&gt;</code> element of your application. Secondly, it’s vital to prevent evaluation on the script responsible for establishing a connection to SPX. This can be achieved by adding a <code>{html} &lt;script spx-eval=&quot;false&quot;&gt;</code> attribute to the tag containing SPX. This precautionary measure ensures that SPX isn’t re-initialized for each navigation. Failure to implement this attribute may lead to SPX re-initializing for all subsequent visits, compromising its intended functionality.</p>
<pre><code class="language-html"><html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My SPX App</title>
    <!--
      Add JavaScript files within the <head> element
    -->
    <script src="bundle.js" spx-eval="false"></script>
  </head>
  <body>
    <!-- Your page content goes here -->
  </body>
</html>
</code></pre>
<hr>
<h1>Creating Components</h1>
<p>Let’s proceed with creating SPX components to integrate into our web application. For a comprehensive understanding, it’s advisable to review the <a href="/components/structure">Components Structure</a> section of the documentation. In this tutorial, we’ll craft simple components and delve into the process of registering and utilizing them effectively.</p>
<p>We’ll commence by developing a fundamental counter component, aiming to enable incrementing and decrementing a number utilizing Component <a href="/components/events">Events</a>, Component <a href="/components/state">State</a>, and Component <a href="/components/nodes">Nodes</a>. Begin by generating a new file named <code>counter.ts</code> within the <code>components</code> directory of your project, and insert the following code:</p>
<!--prettier-ignore-->
<pre><code class="language-ts">import spx, { SPX } from 'spx';

export class Counter extends spx.Component<typeof Counter.define> {

  static define = {
    nodes: <const>['count' ],
    state: {
      count: Number
    }
  };

  increment () {
    this.dom.countNode.innerText = `${++this.state.count}`;
  }

  decrement () {
    this.dom.countNode.innerText = `${--this.state.count}`;
  }

}
</code></pre>
<blockquote>
<p>Notice the extension of <code>spx.Component</code> in our component declaration. This step is essential for SPX components, as <code>spx.Component</code> serves as a base class that provides essential capabilities for component functionality.</p>
</blockquote>
<h1>Registering Component</h1>
<p>Now that we have our component defined, the next step is to register it with SPX so that SPX recognizes its existence. Let’s open up the <code>bundle.ts</code> entry point file where we called <code>spx.connect()</code> and proceed to import and register the component.</p>
<!--prettier-ignore-->
<pre><code class="language-ts">import spx from 'spx';
import { Counter } from './components/counter'

export default spx({
  components: {
    Counter // Provide the component in an object
  }
});
</code></pre>
<blockquote>
<p>You can also register components using the <strong>spx.register</strong> API method. For further details, please refer to the <a href="/components/register">Component Register</a> section of the documentation.</p>
</blockquote>
<hr>
<h1>Counter Markup</h1>
<p>Now, it’s time to integrate our component into the DOM. SPX components follow a simple directive pattern, utilizing attribute references as the control mechanism between the component and the DOM. The static <code>connect</code> object defined on the <code>Counter</code> component class serves as our configuration model, and the data provided via <code>connect</code> will be used by SPX internally when establishing instances.</p>
<!--prettier-ignore-->
<pre><code class="language-html"><section spx-component="counter">
  <!-- Element -->
  <h1>
    Count: <span spx-node="counter.count">0</span>
  </h1>
  <!-- Buttons -->
  <button
    type="button"
    spx@click="counter.increment"> + </button>
  <button
    type="button"
    spx@click="counter.decrement"> - </button>
</section>
</code></pre>
<hr>
<h1>Tabs Component</h1>
<p>A simple counter component is an excellent starting point, but let’s create a slightly more advanced component to explore the capabilities of SPX further. We’ll design a Tabs component that allows us to incorporate tabs into our web application. While still relatively straightforward, this component will enable us to delve into additional features. Following the same approach as with our Counter component, let’s create a new file in the <code>components</code> directory named <code>tabs.ts</code> and add the following code:</p>
<!--prettier-ignore-->
<pre><code class="language-ts">import spx, { SPX } from 'spx';

export class Tabs extends spx.Component<typeof Tabs.define> {

  static define = {
    nodes: <const>['button', 'panel'],
    state: {
      init: Number,
      open: Number
    }
  };

  connect () {
    this.state.hasInit && this.toggle({ attrs: { idx: this.state.init } });
  }

  open (idx: number) {
    this.buttonNode.children[idx].classList.add('active');
    this.panelNodes[idx].classList.remove('d-none');
  }

  close(idx: number) {
    this.dom.buttonNode.children[idx].classList.remove('active');
    this.dom.panelNodes[idx].classList.toggle('d-none', true);
  }

  toggle ({ attrs }: SPX.Event<{ idx: number }>) {
    if (this.state.open === attrs.idx) return;
    this.state.open = attrs.idx;
    this.dom.panelNodes.forEach((_, idx) => idx === attrs.idx ? this.open(idx) : this.close(idx))
  }
}
</code></pre>
<p>Our Tabs component introduces a bit more complexity compared to the Counter component, particularly highlighting the <code>oninit</code> method. SPX components support lifecycle hooks, triggered at various points during rendering and fetching cycles. Another significant aspect of the Tabs component is the <code>event</code> argument passed to the <code>toggle</code> method. Here, we’re leveraging the SPX event <code>attrs</code> feature, enabling parameter values to be passed in via directives in the DOM.</p>
<h1>Register Tabs</h1>
<p>Just as we did with our <a href="#6-registering-component">Counter Component</a>, we need to make SPX aware that the Tabs component exists. Open up the <code>bundle.ts</code> entry point file where we called <code>spx()</code> and let’s register the component.</p>
<!--prettier-ignore-->
<pre><code class="language-ts">import spx from 'spx';
import { Counter } from './components/counter'
import { Tabs } from './components/tabs'

export default spx({
  components: {
    Counter,
    Tabs     // Provide the component in an object
  }
});
</code></pre>
<br>
<h1>Tabs Markup</h1>
<p>In our Tabs component markup, you’ll notice a couple of additional directives within the <code>&lt;section&gt;</code> and <code>&lt;button&gt;</code> elements. These XML-like attributes are known as <a href="/components/state">State Directives</a>. State Directives facilitate the transfer of data from the DOM to our components. They adhere to the <code>spx-&lt;component&gt;:&lt;key&gt;</code> structure and can only be annotated on component and event node types. These directives are responsible for passing data from the DOM to our component, specifically when they are present on component and event node types.</p>
<p>State Directives serve as a means to define component state directly from the DOM, facilitating its usage within our component. These directives establish two-way bindings, seamlessly connecting components and markup to one another. Consequently, any modifications to the state will be automatically reflected in the DOM, ensuring consistent synchronization between the two.</p>
<pre><code class="language-html"><section spx-component="tabs" spx-tabs:init="2">
  <!-- Buttons -->
  <div spx-node="tabs.button">
    <button type="button" spx@click="tabs.toggle" spx-tabs:idx="0">Foo</button>
    <button type="button" spx@click="tabs.toggle" spx-tabs:idx="1">Bar</button>
    <button type="button" spx@click="tabs.toggle" spx-tabs:idx="2">Baz</button>
  </div>
  <!-- Panels -->
  <div spx-node="tabs.panel">
    <h1>Foo Panel</h1>
  </div>
  <div spx-node="tabs.panel">
    <h1>Bar Panel</h1>
  </div>
  <div spx-node="tabs.panel">
    <h1>Baz Panel</h1>
  </div>
</section>
</code></pre>
<blockquote>
<p>The static <code>define.state</code> object serves as an interface for state directives. These directives are considered as default values when provided and are parsed according to the Type Constructor specified.</p>
</blockquote>

  
</body>
</html>